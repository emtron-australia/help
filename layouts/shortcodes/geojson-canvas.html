{{- $attributes := dict }}
{{- $options := dict "width" 800 "height" 400 "bgcolor" "#fff" }}
{{- $geojson := "" }}

{{- range $k, $v := .Params }}
{{- if eq $k "geojson" }}
{{- $geojson = $v }}
{{- else if in (slice "width" "height" "bgcolor") $k }}
{{- $options = $options | merge (dict $k $v) }}
{{- else }}
{{- $attributes = $attributes | merge (dict $k $v) }}
{{- end }}
{{- end }}

{{- if not $geojson }}
{{- errorf "The geojson-canvas shortcode requires a 'geojson' parameter with the file path." }}
{{- end }}

{{- $geoPath := $geojson }}
{{- if not (strings.HasPrefix $geojson "http") }}
{{- if not (strings.HasPrefix $geojson "/") }}
{{- $geoPath = "/" $geojson | strings.TrimLeft "/" }}
{{- end }}
{{- end }}

<canvas id="canvas-{{ .Ordinal }}" width="{{ $options.width }}" height="{{ $options.height }}"
    style="border: 1px solid #ccc; background-color: transparent; {{- if $attributes.style }} {{ $attributes.style }} {{- end }}">
</canvas>

<div style="margin-top: 10px; text-align: center;">
    <button id="pauseBtn-{{ .Ordinal }}"
        style="padding: 8px 16px; background-color: #ff6b6b; color: white; border: none; border-radius: 4px; font-size: 14px; cursor: pointer; margin-right: 10px;">Pause</button>
    <a href="{{ $geoPath }}" download
        style="display: inline-block; padding: 8px 16px; background-color: #0066cc; color: white; text-decoration: none; border-radius: 4px; font-size: 14px;">Download
        Track (GeoJSON)</a>
</div>

<script>
    fetch('{{ $geoPath }}')
        .then(response => {
            if (!response.ok) throw new Error('HTTP error, status: ' + response.status);
            return response.json();
        })
        .then(geojson => {
            const canvas = document.getElementById('canvas-{{ .Ordinal }}');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;

            if (!geojson.features) return;

            geojson.features.forEach(feature => {
                const coords = [];
                if (feature.geometry.type === 'LineString') {
                    coords.push(...feature.geometry.coordinates);
                } else if (feature.geometry.type === 'Polygon') {
                    feature.geometry.coordinates.forEach(ring => coords.push(...ring));
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach(polygon => {
                        polygon.forEach(ring => coords.push(...ring));
                    });
                }
                coords.forEach(coord => {
                    minLon = Math.min(minLon, coord[0]);
                    maxLon = Math.max(maxLon, coord[0]);
                    minLat = Math.min(minLat, coord[1]);
                    maxLat = Math.max(maxLat, coord[1]);
                });
            });

            const lonRange = maxLon - minLon;
            const latRange = maxLat - minLat;
            const centerLon = (minLon + maxLon) / 2;
            const centerLat = (minLat + maxLat) / 2;

            function projectIsometric(lon, lat, angle) {
                // Translate to center around geometric center
                const nx = (lon - centerLon) / lonRange;
                const ny = (lat - centerLat) / latRange;

                // Rotate around center
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const rotX = nx * cos - ny * sin;
                const rotY = nx * sin + ny * cos;

                // Isometric projection (flipped to view from above)
                const iso_x = (rotX - rotY) * 0.866;
                const iso_y = -(rotX + rotY) * 0.5;

                // Scale and center on canvas - increased zoom
                const scale = Math.min(width, height) * 1.1;
                const x = width / 2 + iso_x * scale;
                const y = height / 2 + iso_y * scale;
                return [x, y];
            }

            function drawFrame(angle) {
                ctx.clearRect(0, 0, width, height);

                geojson.features.forEach(feature => {
                    const featureName = feature.properties && feature.properties.name ? feature.properties.name : '';
                    const featureNameLower = featureName.toLowerCase();

                    let strokeColor = '#aaaaaa';
                    if (featureNameLower === 'start') {
                        strokeColor = '#00FF00';
                    } else if (featureNameLower.includes('sector')) {
                        strokeColor = '#0066ff';
                    } else if (featureNameLower === 'trackouter' || featureNameLower === 'trackinner') {
                        strokeColor = '#cccccc';
                    } else if (/^[sc]\d+$/i.test(featureName)) {
                        strokeColor = '#555555';
                    }

                    if (feature.geometry.type === 'LineString') {
                        ctx.beginPath();
                        feature.geometry.coordinates.forEach((coord, i) => {
                            const [x, y] = projectIsometric(coord[0], coord[1], angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        });
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                        const polygons = feature.geometry.type === 'Polygon' ? [feature.geometry.coordinates] : feature.geometry.coordinates;
                        polygons.forEach(polygon => {
                            polygon.forEach(ring => {
                                ctx.beginPath();
                                ring.forEach((coord, i) => {
                                    const [x, y] = projectIsometric(coord[0], coord[1], angle);
                                    if (i === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                });
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                                ctx.fill();
                                ctx.strokeStyle = strokeColor;
                                ctx.stroke();
                            });
                        });
                    }
                });
            }

            let startTime = Date.now();
            let isPaused = false;
            let pausedTime = 0;
            let dragAngle = 0;
            let isDragging = false;
            let dragStartX = 0;

            const pauseBtn = document.getElementById('pauseBtn-{{ .Ordinal }}');

            pauseBtn.addEventListener('click', function () {
                isPaused = !isPaused;
                if (isPaused) {
                    pausedTime = (Date.now() - startTime) / 1000;
                    pauseBtn.textContent = 'Play';
                    pauseBtn.style.backgroundColor = '#51cf66';
                    canvas.style.cursor = 'grab';
                } else {
                    startTime = Date.now() - (pausedTime * 1000);
                    pauseBtn.textContent = 'Pause';
                    pauseBtn.style.backgroundColor = '#ff6b6b';
                    canvas.style.cursor = 'default';
                }
            });

            canvas.addEventListener('mousedown', function (e) {
                if (!isPaused) return;
                isDragging = true;
                dragStartX = e.clientX;
                canvas.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging) return;
                const deltaX = e.clientX - dragStartX;
                dragAngle += deltaX * 0.005;
                dragStartX = e.clientX;
                drawFrame(dragAngle);
            });

            document.addEventListener('mouseup', function () {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            function animate() {
                if (!isPaused) {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const angle = (elapsed * 0.4) % (Math.PI * 2);
                    drawFrame(angle);
                }
                requestAnimationFrame(animate);
            }
            animate();
        })
        .catch(error => console.error('Error loading GeoJSON:', error));
</script>